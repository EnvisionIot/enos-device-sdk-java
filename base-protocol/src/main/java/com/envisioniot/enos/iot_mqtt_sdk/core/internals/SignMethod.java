package com.envisioniot.enos.iot_mqtt_sdk.core.internals;

import com.envisioniot.enos.iot_mqtt_sdk.util.StringUtil;
import com.google.common.collect.ImmutableSet;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;

public enum SignMethod {
    // toUpperCase was used on SHA1 for historical reason. Keep it for compatibility.
    SHA1("sha1", ImmutableSet.of("hmacsha1"), content -> DigestUtils.shaHex(content).toUpperCase()),
    MD5("md5", ImmutableSet.of("hmacmd5"), DigestUtils::md5Hex),
    SHA256("sha256", ImmutableSet.of("hmacsha256"), DigestUtils::sha256Hex);

    private static Logger LOG = LoggerFactory.getLogger(SignMethod.class);

    private final String name;
    private final Set<String> aliases;
    private final Function<String, String> signFunc;

    SignMethod(String name, Set<String> aliases, Function<String, String> signFunc) {
        this.name = name;
        this.aliases = aliases;
        this.signFunc = signFunc;
    }

    public String getName() {
        return name;
    }

    /**
     * Generate signature for the given content
     *
     * @param content to be signed using this sign method
     * @return signature generated by this sign method
     */
    public String sign(String content) {
        return signFunc.apply(content);
    }

    public static SignMethod getSignMethod(String name) {
        if (StringUtil.isNotEmpty(name)) {
            String nm = name.trim().toLowerCase();
            Optional<SignMethod> method = Arrays
                    .stream(SignMethod.values())
                    .filter(s -> s.getName().equals(nm) || s.aliases.contains(nm))
                    .findFirst();
            if (method.isPresent()) {
                return method.get();
            }

            throw new IllegalArgumentException("invalid sign method name: " + name);
        }

        // If no specific sign is provided, we use SHA1 as default for historical
        // compatibility. However, this should normally not happen.
        LOG.error("sign method not provided, use SHA1 as default");
        return SignMethod.SHA1;
    }

    @Override
    public String toString() {
        return getName();
    }

    public static void main(String[] args) {
        System.out.println(SignMethod.getSignMethod("sha1"));
        System.out.println(SignMethod.getSignMethod("SHA1"));
        System.out.println(SignMethod.getSignMethod("hmacmd5"));
        System.out.println(SignMethod.getSignMethod("sha256"));
        System.out.println(SignMethod.getSignMethod(""));
        System.out.println(SignMethod.getSignMethod(null));
        System.out.println(SignMethod.getSignMethod("sha512"));
    }
}
